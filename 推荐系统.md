# 推荐系统

## 1. 定义

### 1.1 数学定义：

```C``` 为全体用户集合

```S``` 为全部商品、内容集合

```u``` 为评价把```s```推荐给```c```的好坏 评判函数
$$
对于 c \in C ,找到s \in S，使得u最大
$$
即
$
\forall c \in C,s^`_c = argmax(u(c,s))   s \in S
$


### 1.2 通俗的讲

根据用户的```历史行为，社交关系，兴趣点，上下文环境 等```去判断用户的当前需求的item 



## 2. 结构



**offline** ：数据处理、建模

**online** ：实时



## 3. 评定标准



### 准确度

* 打分系统

$$
r_{ui} 是实际评分，r^`_{ui}是预测评分
$$


$$
RMSE = \sqrt{ \frac{\sum{_{ui \in T}}(r_{ui}-r^`_{ui})^2}{|T|}}
$$

$$
MAE = \frac{\sum_{u,i \in T}|r_{ui}-r^`_{ui}|}{|T|}
$$

* Top N

$$
R(u)为根据训练建立的模型在测试集上的推荐，T(u)为测试集上用户的选择
$$

$$
Precision=\frac{\sum _{u \in U}|R(u) \cap T(u)|}{\sum_{u \in U}|R(u)|}
$$

$$
Recall=\frac{\sum _{u \in U}|R(u) \cap T(u)|}{\sum_{u \in U}|T(u)|}
$$



### 覆盖率

防止马太效应（热越热，冷越冷）
$$
Coverage=\frac {|U_{u \in U} R(u)|}{|I|}
$$

$$
信息熵  H = - \sum ^n _{i=1} p(i) logp(i)
$$

```p(i)```  一个商品推荐的次数 除以 总的次数



### 多样性

推荐列表中物品两两之间的不相似性。设```s(i,j)```表示物品i跟j之间的相似度
$$
Diversity(R(u)) = 1 - \frac{\sum_{i,j \in R(u) ,i\not=j}s(i,j)}{\frac{1}{2}|R(u)|(|R(u)|-1)}
$$

$$
其中 \frac{1}{2}|R(u)|(|R(u)|-1)   就是 C^2 _n = \frac{n(n-1)}{2}
$$

### 其他

* 新颖度
* 惊喜度
* 信任度：推荐理由
* 实时性



## 4. 经典算法

### 4.1 基于内容的推荐

* 基于用户喜欢的item属性或内容
* 分析内容，无其他用户行为
* 多用于文本
* item通过内容（关键词）关联
  * 题材
  * 主演
  * 年代
* 对比item内容



要对每个要推荐的内容，建立一份资料

* 词k_i在文件d_j中的权重w_i,j
* tf-idf

用户也要一份资料

* 定义一个权重向量（w_c1, w_c2, w_c3, ... w_cn）
* 其中w_ci表示第ni个词对用户c的重要度

计算匹配度

​	余弦相似度
$$
u(c,s) = cos(\vec w_c,\vec w_s) = \frac{\vec w_c · \vec w_s}{||\vec w_c||_2 * ||\vec w_s||_2} = \frac{\sum ^K _{i=1} w_{i,c} w_{i,s}}{\sqrt {\sum ^K _{i=1} w^2 _{i,c}} \sqrt{\sum ^K _{i=1}w^2 _{i,s}}}
$$


### 4.2 协同过滤

**相似度、距离定义** 

* 欧式距离



* Jaccard相似度

$$
J(A,B) = \frac{|A \cap B|}{|A\cup B|}
$$

* 余弦相似度



* Pearson相似度

  ​		每一项减掉均值





#### 4.2.1 基于用户 CF

找到与用户最近的**其他用户**，找到他们相关的item，根据距离加权打分

- 一个用户序列u_i, i = 1,...,n。一个item序列p_j, j = 1,...,m
- 一个n*m的矩阵v, 每个元素v_i,j表示用户i对j的打分
- 计算相似度

减均值->为了归一化（每个人评价标准不一样）



#### 4.2.2 基于item CF

根据用户的商品、内容的行为，计算item和item相似度，找到和当前item最近的进行推荐

* 一个用户序列u_i, i = 1,...,n。一个item序列p_j, j = 1,...,m

* 一个n*m的矩阵v, 每个元素v_i,j表示用户i对j的打分

* 计算item和item之间的相似度/距离

* $$
  S(i,j) = cos(\vec i,\vec j) = \frac {\vec i*\vec j}{||\vec i||_2 * ||\vec j||_2}
  $$

* Top K





**一般用基于item **，因为**用户太多了**

稳定度相对来说 item的高



#### 4.2.3 协同过滤 优缺点

优点：

* 行为丰富情况下，效果好
* 结构简单

缺点：

* 数据稀疏受影响。考虑二度关联





### 4.3 冷启动

* 对于新用户
  * 推荐热门
  * 根据注册信息
* 新商品
  * 求与原来商品的相似度
  * 基于item-based协同过滤





## 5. 进阶

### 5.1 隐语义模型

有些位置是空的，没打分。想办法填满未打分项。

**想法** 用一些隐藏的因素打分



**假定**： 隐藏因子的个数小于user跟item数

因为 如果每个user都关联一个独立的隐藏因子，就没法预测。





通过中间隐含变量 将user跟item关联起来。

user、item矩阵 变成 user、隐因子   跟 item、隐因子



最简单的是 **矩阵分解MF**



* 假设有U个用户，D个item，R为打分矩阵

* 假设有K个隐含变量，需要找到矩阵P(U * K)和Q(D * K)

$$
R \approx P \times Q^T = \hat R
$$

$$
\hat r_{ij} = p^T _i q_j = \sum^k _{k=1} p_{ik}q_{kj}
$$

* 怎么求最佳的P和Q

  * 梯度下降

    * 损失函数

    * $$
      e^2 _{ij} = (r_{ij}-\hat r_{ij})^2 = (r_{ij}-\sum^K _{k=1}p_{ik}q_{kj})^2
      $$

      * ​	

    * 求梯度

加正则化项 防止=
$$
e^2 _{ij} = (r_{ij} - \sum ^K_{k=1}p_{ik}q_{kj})^2 + \frac {\beta}{2}\sum ^K_{k=1}(||P||^2+ ||Q||^2)
$$
zai再求梯度



P和Q元素是非负的



再加上用户偏差 电影偏差项 
